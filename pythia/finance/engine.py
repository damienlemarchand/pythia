# -*- coding: utf-8 -*-
"""
Created on 2018-12-14

Contains all the functions that will be used to generate flows and positions
The purpose is to held position and be able to forecast such positions

Several key concepts are used in this module.

Product
========
Abstract of concept of any financial instrument or any commitment that will trigger flows
Currencies are product that doesn't trigger any flows

Product should be created by function whose signature is
* product_id
**keyargs
and return a function used to generate flows

Trade
========
Exchange of a quantity of product vs an amount of cash between two le_np
Expected fields are
* quantity
* price
* notional ( quantity * price, but sometimes it's more convenient to set the notional and the quantity)
* buyer_le_np_id
* seller_le_np_id
* trade_date
* settle_date
* payment_date
* currency
* product_type
* product_id
* [trade_id]


Flow
======
a transfer of a quantity of product between two legal entity / natural person (noted as le_np).
The le_np referenced in the field from_le_np_id is the source of the flows
The flow happens on a given date (the value date), the amount can be uncertain (i.e floating rate not already fixed)

Cash flows are a specific type of flows which concerns currencies product.
In this case the quantity of product is an amount.

As usual, flow is a dict with such expected fields :
    * value_date : the effective value date of the transfer. This date can be null for optional flows.
    This date can be a theoretical date for non settled flows.
    * product_type : Mandatory. The type of the product transferred. CURRENCY for cash flows
    * product_id : identifier of the product. The tuple product_type/ product_id is a way to identify
    the underlying product. Should be iso3 currency code for cash flows
    * flow_type : string, classification of flows. Ex: NOTIONAL, INTEREST, FEE, DIVIDEND.
    * quantity : float, quantity of product transferred. Positive means the quantity is transfered
    from the 'from_le_np_id' to 'to_le_np_id'
    * from_le_np_id : identifier of the legal entity / natural person source of the flows.
    * to_le_np_id : identifier of the legal entity / natural person receiving the product.
    * reconciliated_bank_records : list, can be empty.

LE_NP
=======
Single concept meaning either Legal Entity or a Natural Person

Position
==========
a position is the quantity of product held by an LE_NP for a period of time
A position is the consequences of accumulated flows of a product.
A non zero position of product can trigger flows (Ex. A position on a loan will trigger principal and interest flows)

    * le_np_id : identifier of the LE_NP
    * product_type, product_id.
    * quantity
    * from_date: starting moment of time, included
    * to_date: ending validity of the position. Not included. None means infinite.
    * product : optional, full description of the product
    * business_unit : optional

Position Registry
======================
A dict structure that holds all the position for a set of le_np entity
key : le_np
value : positions on all instruments, a dict :
        key : business unit, "none" means position without any business unit specified
        value : a dict
            key : product_type
            value: a dict
                key : product_id
                value: a dict
                     property 'positions' :
                         an array of position expressed as dict
                             * quantity
                             * from_date: starting moment of time, included
                             * to_date: ending validity of the position. Not included. None means infinite.
                             * in_flows : array of flows that happened on from_date
                     property 'out_flows' :
                         an array of flows generated by the positions

Product registry
==================
a dict structure that contains data used to create the flow generator function
    key : product type
    value : a dict
        key : product_id, key value "default" return a defaulting data structure
        value: a dict that hold all the data used to generate functions



@author: dlemarchand
"""

import pythia.finance.product as py_fi_pr

POSITION_FLOW_TYPE = "SETTLE"
PAYMENT_FLOW_TYPE = "TRADE_CASH_FLOW"


def create_position_registry(le_np_id):
    return {le_np_id: {}}


def generate_trade_flows(trade, custom_generator=None, additional_flows_generator=None):
    """
    :param trade: a dict describing the trade
    :param custom_generator: a function that can be used to customize the flow generation.
        The function takes two argument :
            * trade
            * a flow
    :param additional_flows_generator: a function that can be used to create additional flows (like fees)
            The function takes two argument :
            * trade
            * the custom_generator
    :return:  an array of flows
    """
    flows = []
    if trade['quantity']:
        settle_flow = {'value_date': trade['settle_date'],
                       'product_type': trade['product_type'],
                       'product_id': trade['product_id'],
                       'flow_type': POSITION_FLOW_TYPE,
                       'from_le_np_id': trade['seller_le_np_id'],
                       'to_le_np_id': trade['buyer_le_np_id'],
                       'quantity': trade['quantity']}
        if 'trade_id' in trade:
            settle_flow['source_trade_id'] = trade['trade_id']
        if 'business_unit' in trade:
            settle_flow['from_business_unit'] = trade['business_unit']
            settle_flow['to_business_unit'] = trade['business_unit']
        else:
            if 'from_business_unit' in trade and 'to_business_unit' in trade:
                if trade['from_business_unit'] and trade['to_business_unit']:
                    settle_flow['from_business_unit'] = trade['from_business_unit']
                    settle_flow['to_business_unit'] = trade['to_business_unit']
        if custom_generator:
            custom_generator(trade, settle_flow)
        flows.append(settle_flow)
    notional = None
    if 'notional' in trade:
        notional = trade['notional']
    if not notional:
        if 'quantity' in trade and 'price' in trade:
            notional = trade['quantity'] * trade['price']
    if notional:
        payment_flow = {'value_date': trade['payment_date'],
                        'product_type': 'CURRENCY',
                        'product_id': trade['currency'],
                        'flow_type': PAYMENT_FLOW_TYPE,
                        'from_le_np_id': trade['seller_le_np_id'],
                        'to_le_np_id': trade['buyer_le_np_id'],
                        'quantity': -1.0*notional}
        if 'trade_id' in trade:
            payment_flow['source_trade_id'] = trade['trade_id']
        if 'business_unit' in trade:
            payment_flow['from_business_unit'] = trade['business_unit']
            payment_flow['to_business_unit'] = trade['business_unit']
        else:
            if 'from_business_unit' in trade and 'to_business_unit' in trade:
                if trade['from_business_unit'] and trade['to_business_unit']:
                    payment_flow['from_business_unit'] = trade['from_business_unit']
                    payment_flow['to_business_unit'] = trade['to_business_unit']
        if custom_generator:
            custom_generator(trade, payment_flow)
        flows.append(payment_flow)
    if additional_flows_generator:
        flows.extend(additional_flows_generator(trade, custom_generator))
    return flows


def select_position(position_array, date):
    for position in position_array:
        if position['from_date'] <= date:
            if not position['to_date']:
                return position
            else:
                if position['to_date'] > date:
                    return position


def select_positions_after(position_array, date):
    selected = []
    for position in position_array:
        if position['from_date'] >= date:
            selected.append(position)
    return selected


def amend_position(le_np_id, bu_unit, position_registry, flow, product_registry=None):
    """
    Amend the position registry according to the flow.
    The position amended will trigger the generation of resulting flows
    :param le_np_id:
    :param bu_unit:
    :param position_registry:
    :param flow:
    :param product_registry:
    :return:
    """
    position_set = position_registry[le_np_id]
    if bu_unit not in position_set:
        position_set[bu_unit] = {}
    if flow['product_type'] not in position_set[bu_unit]:
        position_set[bu_unit][flow['product_type']] = {}
    if flow['product_id'] not in position_set[bu_unit][flow['product_type']]:
        position_set[bu_unit][flow['product_type']][flow['product_id']] = {'positions': [], 'out_flows': []}
    flow_position = flow['quantity']
    if flow['from_le_np_id'] == le_np_id:
        flow_position = flow['quantity'] * -1.0
    if flow['from_le_np_id'] == flow['to_le_np_id'] and bu_unit == flow['from_business_unit']:
        # internal flow
        flow_position = flow['quantity'] * -1.0
    if not flow_position:
        return
    position_keeping_dict = position_set[bu_unit][flow['product_type']][flow['product_id']]
    new_position = []

    if len(position_keeping_dict['positions']) == 0:
        first_one = {'from_date': flow['value_date'],
                     'to_date': None,
                     'quantity': flow_position,
                     'in_flows': [flow]}
        new_position.append(first_one)
    else:
        found = False
        period_after_found = False
        min_from_date = None
        for item in position_keeping_dict['positions']:
            if item['to_date'] and flow['value_date'] >= item['to_date']:
                # flow after current period
                new_position.append(item)
            else:
                if flow['value_date'] < item['from_date']:
                    # flow before current period
                    item['quantity'] = item['quantity'] + flow_position
                    new_position.append(item)
                    period_after_found = True
                    if not min_from_date:
                        min_from_date = item['from_date']
                    else:
                        if min_from_date > item['from_date']:
                            min_from_date = item['from_date']
                else:
                    # flow in the period
                    found = True
                    if item['from_date'] == flow['value_date']:
                        # merge the quantities
                        item['quantity'] = item['quantity'] + flow_position
                        item['in_flows'].append(flow)
                        new_position.append(item)
                    else:
                        # flow in the period but after the beginning of the period, must split the period
                        before = {'from_date': item['from_date'],
                                  'to_date': flow['value_date'],
                                  'quantity': item['quantity'],
                                  'in_flows': item['in_flows']}
                        new_position.append(before)
                        after = {'from_date': flow['value_date'],
                                 'to_date': item['to_date'],
                                 'quantity': item['quantity'] + flow_position,
                                 'in_flows': [flow]}
                        new_position.append(after)
        if not found:
            if period_after_found and min_from_date:
                before_period = {'from_date': flow['value_date'],
                                 'to_date': min_from_date,
                                 'quantity': flow_position,
                                 'in_flows': [flow]}
                new_position.append(before_period)
    new_position.sort(key=lambda position_item: position_item['from_date'])
    position_keeping_dict['positions'] = new_position
    if product_registry:
        flow_generator = py_fi_pr.find_flow_generator(product_registry,
                                                      flow['product_type'],
                                                      flow['product_id'])
        if flow_generator:
            resulting_flows = flow_generator(le_np_id, bu_unit, flow['value_date'], new_position)
            if resulting_flows:
                for fl in resulting_flows:
                    position_keeping_dict['out_flows'].append(fl)
                    amend_position_registry(position_registry, fl, product_registry=product_registry)


def amend_position_registry(position_registry, flow, product_registry=None):
    if flow['from_le_np_id'] in position_registry:
        bu_unit = None
        if 'from_business_unit' in flow:
            bu_unit = flow['from_business_unit']
        if not bu_unit:
            bu_unit = "none"

        amend_position(flow['from_le_np_id'], bu_unit,
                       position_registry,
                       flow,
                       product_registry=product_registry)
    if flow['to_le_np_id'] in position_registry:
        bu_unit = None
        if 'to_business_unit' in flow:
            bu_unit = flow['to_business_unit']
        if not bu_unit:
            bu_unit = "none"
        amend_position(flow['to_le_np_id'], bu_unit,
                       position_registry,
                       flow,
                       product_registry=product_registry)



